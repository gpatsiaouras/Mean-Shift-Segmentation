import time
import numpy as np
import scipy.io
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


class Segmentation:
    def __init__(self, data, radius):
        """
        Assigns data and radius
        Initiates a threshold and a conversion threshold, an empty list to save peaks,
        an vector of labels with default value -1
        :param data:
        :param radius:
        """
        self.data = data
        self.radius = radius
        self.conversion_threshold = self.radius / 2
        self.threshold = 0.01
        self.peaks = []
        # Initiate labels with -1 values indicating that there is no label assigned yet
        self.labels = np.ones(data.shape[1]) * -1

    def find_peak(self, previous_data_point):
        """
        Applies iterative process that based on a sphere of data generated by a radius
        it finds the mean point and then shifts the sphere to the new mean point until the
        sphere stops moving. It returns the peak and the points inside the sphere.
        :param previous_data_point:
        :return mean_data_point, points_in_radius: Peak found and points at range
        """
        neighbors, points_in_radius = self.get_data_in_radius_from_point(previous_data_point)
        mean_data_point = np.mean(neighbors, axis=1).reshape(self.data.shape[0], 1)
        while not self.converged(mean_data_point, previous_data_point):
            previous_data_point = mean_data_point
            neighbors, points_in_radius = self.get_data_in_radius_from_point(mean_data_point)
            mean_data_point = np.mean(neighbors, axis=1).reshape(self.data.shape[0], 1)

        return mean_data_point, points_in_radius

    def mean_shift(self):
        """
        Mean shift implementation, iterates over data points and for each one it finds
        the peak and assigns the approriate label.
        """
        start_time = time.time()
        for i in range(self.data.shape[1]):
                peak, points_in_radius = self.find_peak(self.data[:, i].reshape(self.data.shape[0], 1))
                self.labels[i] = self.get_label_for_point(peak)

        print("\rMean Shift: {0:.2f} seconds".format(time.time() - start_time) * 1000)

    def mean_shift_opt(self):
        """
        Optimized mean shift algorithm applying optimization of basin of attraction and
        points along the search path association with the converged peak.
        """
        start_time = time.time()
        for i in range(self.data.shape[1]):
            if self.labels[i] == -1:
                peak, points_in_radius = self.find_peak(self.data[:, i].reshape(self.data.shape[0], 1))
                self.labels[i] = self.get_label_for_point(peak)
                self.labels[points_in_radius] = self.labels[i]

        print("\rOptimized Mean Shift: {0:.2f} seconds".format(time.time() - start_time) * 1000)

    def get_data_in_radius_from_point(self, cluster_point):
        """
        Applies a sphere with specified radius and filters and returns the data points
        belonging to this sphere. It also returns the conditional array holding the indices
        of each point from the original array and True or False, indicating if they belong
        to the current sphere or not.
        :param cluster_point: Center of sphere
        :return points_in_range, indices_of_points: Points in range their indices
        """
        points_in_radius = np.linalg.norm(cluster_point - self.data, axis=0) < self.radius
        extracted = np.extract(np.tile(points_in_radius, (3, 1)), self.data)
        return extracted.reshape(3, extracted.shape[0] // 3), points_in_radius

    def converged(self, mean_data_point, previous_data_point):
        """
        Checks if the mean data point is close enough to the previous mean data point
        and returns true if it is less than the threshold.
        :param mean_data_point: Current center of sphere
        :param previous_data_point: Previous center of sphere
        :return True or False: True if it converged, False if not
        """
        return np.linalg.norm(mean_data_point - previous_data_point) < self.threshold

    def get_label_for_point(self, new_peak):
        """
        Searches if the new_peak found already exists in the peaks list by
        using a threshold between the values. If the peak exists it returns the index
        of the peak, otherwise adds the peak to the list and returns last index.
        :param new_peak: New peak found for this point
        :return index of peak: Index of the peak in the peaks list
        """
        for peak_idx in range(len(self.peaks)):
            if (np.abs(new_peak - self.peaks[peak_idx]) < self.conversion_threshold).all():
                return peak_idx

        self.peaks.append(new_peak)

        return len(self.peaks) - 1


if __name__ == "__main__":
    # Read data
    data = np.array(scipy.io.loadmat('pts.mat')['data'])

    # Without Optimization
    image_seg = Segmentation(data, 2)
    image_seg.mean_shift()

    # With Optimization
    image_seg_opt = Segmentation(data, 2)
    image_seg_opt.mean_shift_opt()

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(data[0], data[1], data[2])
    peaks = np.array(image_seg.peaks).reshape(2, 3).T
    ax.scatter(peaks[0], peaks[1], peaks[2])
    plt.show()

    # print(image_seg.labels)
